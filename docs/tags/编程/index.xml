<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on WiseAI的博客</title>
    <link>http://wiseai.cn/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on WiseAI的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>陇ICP备15000157号</copyright>
    <lastBuildDate>Tue, 23 Aug 2022 10:33:39 +0800</lastBuildDate><atom:link href="http://wiseai.cn/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>golang使用smtp发送Email</title>
      <link>http://wiseai.cn/post/email/</link>
      <pubDate>Tue, 23 Aug 2022 10:33:39 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/email/</guid>
      <description>几个开源的代码：
email 这个代码比较清晰，我现在用的就是这个，Star2.1k gomail 没用过，Star3.7k mailhog 这个Star10.7，看着是不错功能强大，但是依赖太多，没深入学习 邮件相关汇总 这个是一个邮件相关代码汇总的帖子，内容比较旧了，但是可以参考学习下 使用ssl的例子：
import ( &amp;#34;tls.Config&amp;#34; &amp;#34;email&amp;#34;//引入包，看怎么引入了 ) func SendMail(s string) error { e := NewEmail() e.From = &amp;#34;发送邮箱&amp;#34; e.To = []string{&amp;#34;目标邮箱&amp;#34;} // e.Bcc = []string{&amp;#34;bcc@junzhe.net&amp;#34;} // e.Cc = []string{&amp;#34;cc@junzhe.net&amp;#34;} //这两个基本不用 e.Subject = &amp;#34;这个是主题&amp;#34; // e.Text = []byte(&amp;#34;这里是内容&amp;#34;) e.HTML = []byte(&amp;#34;这是HTML格式的内容&amp;#34;) t := &amp;amp;tls.Config{InsecureSkipVerify: true, ServerName: &amp;#34;这里是smtp服务器&amp;#34;} err := e.SendWithTLS(&amp;#34;smtp服务器:465&amp;#34;, smtp.PlainAuth(&amp;#34;&amp;#34;, &amp;#34;邮箱名&amp;#34;, &amp;#34;密码&amp;#34;, &amp;#34;smtp服务器&amp;#34;), t) return err } </description>
    </item>
    
    <item>
      <title>Go程序的字符串、数组和切片的应用</title>
      <link>http://wiseai.cn/post/golang/2022.07.31-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 31 Jul 2022 11:53:44 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.31-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>7.6 字符串、数组和切片的应用 7.6.1 从字符串生成字节切片 假设 s 是一个字符串（本质上是一个字节数组），那么就可以直接通过 c := []byte(s) 来获取一个字节的切片 c 。另外，您还可以通过 copy() 函数来达到相同的目的：copy(dst []byte, src string)。
同样的，还可以使用 for-range 来获得每个元素（Listing 7.13 — for_string.go）：
package main import &amp;#34;fmt&amp;#34; func main() { s := &amp;#34;\u00ff\u754c&amp;#34; for i, c := range s { fmt.Printf(&amp;#34;%d:%c &amp;#34;, i, c) } } 输出：
0:ÿ 2:界 我们知道，Unicode 字符会占用 2 个字节，有些甚至需要 3 个或者 4 个字节来进行表示。如果发现错误的 UTF8 字符，则该字符会被设置为 U+FFFD 并且索引向前移动一个字节。和字符串转换一样，您同样可以使用 c := []int32(s) 语法，这样切片中的每个 int 都会包含对应的 Unicode 代码，因为字符串中的每次字符都会对应一个整数。类似的，您也可以将字符串转换为元素类型为 rune 的切片：r := []rune(s)。</description>
    </item>
    
    <item>
      <title>Go程序的切片的复制与追加</title>
      <link>http://wiseai.cn/post/golang/2022.07.30-%E5%88%87%E7%89%87%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%BF%BD%E5%8A%A0/</link>
      <pubDate>Sat, 30 Jul 2022 11:52:29 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.30-%E5%88%87%E7%89%87%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%BF%BD%E5%8A%A0/</guid>
      <description>7.5 切片的复制与追加 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。下面的代码描述了从拷贝切片的 copy 函数和向切片追加新元素的 append() 函数。
示例 7.12 copy_append_slice.go
package main import &amp;#34;fmt&amp;#34; func main() { slFrom := []int{1, 2, 3} slTo := make([]int, 10) n := copy(slTo, slFrom) fmt.Println(slTo) fmt.Printf(&amp;#34;Copied %d elements\n&amp;#34;, n) // n == 3 sl3 := []int{1, 2, 3} sl3 = append(sl3, 4, 5, 6) fmt.Println(sl3) } func append(s[]T, x ...T) []T 其中 append() 方法将 0 个或多个具有相同类型 s 的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素是同类型。如果 s 的容量不足以存储新增元素，append() 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append() 方法总是返回成功，除非系统内存耗尽了。
如果你想将切片 y 追加到切片 x 后面，只要将第二个参数扩展成一个列表即可：x = append(x, y.</description>
    </item>
    
    <item>
      <title>Go程序的切片重组reslice</title>
      <link>http://wiseai.cn/post/golang/2022.07.29-%E5%88%87%E7%89%87%E9%87%8D%E7%BB%84reslice/</link>
      <pubDate>Fri, 29 Jul 2022 11:51:11 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.29-%E5%88%87%E7%89%87%E9%87%8D%E7%BB%84reslice/</guid>
      <description>7.4 切片重组 (reslice) 我们已经知道切片创建的时候通常比相关数组小，例如：
slice1 := make([]type, start_length, capacity) 其中 start_length 作为切片初始长度而 capacity 作为相关数组的长度。
这么做的好处是我们的切片在达到容量上限后可以扩容。改变切片长度的过程称之为切片重组 reslicing，做法如下：slice1 = slice1[0:end]，其中 end 是新的末尾索引（即长度）。
将切片扩展 1 位可以这么做：
sl = sl[0:len(sl)+1] 切片可以反复扩展直到占据整个相关数组。
示例 7.11 reslicing.go
package main import &amp;#34;fmt&amp;#34; func main() { slice1 := make([]int, 0, 10) // load the slice, cap(slice1) is 10: for i := 0; i &amp;lt; cap(slice1); i++ { slice1 = slice1[0:i+1] slice1[i] = i fmt.Printf(&amp;#34;The length of slice is %d\n&amp;#34;, len(slice1)) } // print the slice: for i := 0; i &amp;lt; len(slice1); i++ { fmt.</description>
    </item>
    
    <item>
      <title>Go程序的for Range结构</title>
      <link>http://wiseai.cn/post/golang/2022.07.28-for-range%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 28 Jul 2022 11:49:16 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.28-for-range%E7%BB%93%E6%9E%84/</guid>
      <description>7.3 For-range 结构 这种构建方法可以应用于数组和切片:
for ix, value := range slice1 { ... } 第一个返回值 ix 是数组或者切片的索引，第二个是在该索引位置的值；他们都是仅在 for 循环内部可见的局部变量。value 只是 slice1 某个索引位置的值的一个拷贝，不能用来修改 slice1 该索引位置的值。
示例 7.9 slices_forrange.go
package main import &amp;#34;fmt&amp;#34; func main() { var slice1 []int = make([]int, 4) slice1[0] = 1 slice1[1] = 2 slice1[2] = 3 slice1[3] = 4 for ix, value := range slice1 { fmt.Printf(&amp;#34;Slice at %d is: %d\n&amp;#34;, ix, value) } } 示例 7.10 slices_forrange2.go</description>
    </item>
    
    <item>
      <title>Go程序的切片</title>
      <link>http://wiseai.cn/post/golang/2022.07.27-%E5%88%87%E7%89%87/</link>
      <pubDate>Wed, 27 Jul 2022 11:47:31 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.27-%E5%88%87%E7%89%87/</guid>
      <description>7.2 切片 7.2.1 概念 切片 (slice) 是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。
切片是可索引的，并且可以由 len() 函数获取长度。
给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0， 最大为相关数组的长度：切片是一个 长度可变的数组。
切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少：它等于切片的长度 + 数组除切片之外的长度。如果 s 是一个切片，cap(s) 就是从 s[0] 到数组末尾的数组长度。切片的长度永远不会超过它的容量，所以对于切片 s 来说该不等式永远成立：0 &amp;lt;= len(s) &amp;lt;= cap(s)。
多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。
优点 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中切片比数组更常用。
声明切片的格式是： var identifier []type（不需要说明长度）。
一个切片在未初始化之前默认为 nil，长度为 0。
切片的初始化格式是：var slice1 []type = arr1[start:end]。
这表示 slice1 是由数组 arr1 从 start 索引到 end-1 索引之间的元素构成的子集（切分数组，start:end 被称为切片表达式）。所以 slice1[0] 就等于 arr1[start]。这可以在 arr1 被填充前就定义好。
如果某个人写：var slice1 []type = arr1[:] 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 arr1[0:len(arr1)] 的一种缩写）。另外一种表述方式是：slice1 = &amp;amp;arr1。</description>
    </item>
    
    <item>
      <title>Go程序的数组声明和初始化</title>
      <link>http://wiseai.cn/post/golang/2022.07.26-%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Tue, 26 Jul 2022 11:45:21 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.26-%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>7.1 声明和初始化 7.1.1 概念 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列（这是一种同构的数据结构）；这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。数组长度必须是一个常量表达式，并且必须是一个非负整数。数组长度也是数组类型的一部分，所以 [5]int 和 [10]int 是属于不同类型的。数组的编译时值初始化是按照数组顺序完成的（如下）。
注意事项 如果我们想让数组元素类型为任意类型的话可以使用空接口作为类型（参考 第 11 章）。当使用值时我们必须先做一个类型判断（参考 第 11 章）。
数组元素可以通过 索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推（数组以 0 开始在所有类 C 语言中是相似的）。元素的数目（也称为长度或者数组大小）必须是固定的并且在声明该数组时就给出（编译时需要知道数组长度以便分配内存）；数组长度最大为 2GB。
声明的格式是：
var identifier [len]type 例如：
var arr1 [5]int 在内存中的结构是：
每个元素是一个整型值，当声明数组时所有的元素都会被自动初始化为默认值 0。
arr1 的长度是 5，索引范围从 0 到 len(arr1)-1。
第一个元素是 arr1[0]，第三个元素是 arr1[2]；总体来说索引 i 代表的元素是 arr1[i]，最后一个元素是 arr1[len(arr1)-1]。
对索引项为 i 的数组元素赋值可以这么操作：arr[i] = value，所以数组是 可变的。
只有有效的索引可以被使用，当使用等于或者大于 len(arr1) 的索引时：如果编译器可以检测到，会给出索引超限的提示信息；如果检测不到的话编译会通过而运行时会 panic():（参考第 13 章）
runtime error: index out of range 由于索引的存在，遍历数组的方法自然就是使用 for 结构：</description>
    </item>
    
    <item>
      <title>Go程序的应用闭包：将函数作为返回值</title>
      <link>http://wiseai.cn/post/golang/2022.07.25-%E5%BA%94%E7%94%A8%E9%97%AD%E5%8C%85%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC/</link>
      <pubDate>Mon, 25 Jul 2022 11:41:39 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.25-%E5%BA%94%E7%94%A8%E9%97%AD%E5%8C%85%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC/</guid>
      <description>6.9 应用闭包：将函数作为返回值 在程序 function_return.go 中我们将会看到函数 Add2() 和 Adder() 均会返回签名为 func(b int) int 的函数：
func Add2() (func(b int) int) func Adder(a int) (func(b int) int) 函数 Add2() 不接受任何参数，但函数 Adder() 接受一个 int 类型的整数作为参数。
我们也可以将 Adder() 返回的函数存到变量中 (function_return.go)。
package main import &amp;#34;fmt&amp;#34; func main() { // make an Add2 function, give it a name p2, and call it: p2 := Add2() fmt.Printf(&amp;#34;Call Add2 for 3 gives: %v\n&amp;#34;, p2(3)) // make a special Adder function, a gets value 2: TwoAdder := Adder(2) fmt.</description>
    </item>
    
    <item>
      <title>Go程序的闭包</title>
      <link>http://wiseai.cn/post/golang/2022.07.24-%E9%97%AD%E5%8C%85/</link>
      <pubDate>Sun, 24 Jul 2022 11:40:02 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.24-%E9%97%AD%E5%8C%85/</guid>
      <description>6.8 闭包 当我们不希望给函数起名字的时候，可以使用匿名函数，例如：func(x, y int) int { return x + y }。
这样的一个函数不能够独立存在（编译器会返回错误：non-declaration statement outside function body），但可以被赋值于某个变量，即保存函数的地址到变量中：fplus := func(x, y int) int { return x + y }，然后通过变量名对函数进行调用：fplus(3,4)。
当然，您也可以直接对匿名函数进行调用：func(x, y int) int { return x + y } (3, 4)。
下面是一个计算从 1 到 100 万整数的总和的匿名函数：
func() { sum := 0 for i := 1; i &amp;lt;= 1e6; i++ { sum += i } }() 表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。
下面的例子展示了如何将匿名函数赋值给变量并对其进行调用（function_literal.go）：
package main import &amp;#34;fmt&amp;#34; func main() { f() } func f() { for i := 0; i &amp;lt; 4; i++ { g := func(i int) { fmt.</description>
    </item>
    
    <item>
      <title>Go程序中将函数作为参数</title>
      <link>http://wiseai.cn/post/golang/2022.07.23-%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 23 Jul 2022 18:06:32 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.23-%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0/</guid>
      <description>6.7 将函数作为参数 函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。下面是一个将函数作为参数的简单例子（function_parameter.go）：
package main import ( &amp;#34;fmt&amp;#34; ) func main() { callback(1, Add) } func Add(a, b int) { fmt.Printf(&amp;#34;The sum of %d and %d is: %d\n&amp;#34;, a, b, a+b) } func callback(y int, f func(int, int)) { f(y, 2) // this becomes Add(1, 2) } 输出：
The sum of 1 and 2 is: 3 将函数作为参数的最好的例子是函数 strings.IndexFunc()：
该函数的签名是 func IndexFunc(s string, f func(c rune) bool) int，它的返回值是字符串 s 中第一个使函数 f(c) 返回 true 的 Unicode 字符的索引值。如果找不到，则返回 -1。</description>
    </item>
    
    <item>
      <title>Go程序的递归函数</title>
      <link>http://wiseai.cn/post/golang/2022.07.22-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 Jul 2022 16:19:22 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.22-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</guid>
      <description>6.6 递归函数 当一个函数在其函数体内调用自身，则称之为递归。最经典的例子便是计算斐波那契数列，即前两个数为 1，从第三个数开始每个数均为前两个数之和。
数列如下所示：
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, … 下面的程序可用于生成该数列（示例 6.13 fibonacci.go）：
package main import &amp;#34;fmt&amp;#34; func main() { result := 0 for i := 0; i &amp;lt;= 10; i++ { result = fibonacci(i) fmt.Printf(&amp;#34;fibonacci(%d) is: %d\n&amp;#34;, i, result) } } func fibonacci(n int) (res int) { if n &amp;lt;= 1 { res = 1 } else { res = fibonacci(n-1) + fibonacci(n-2) } return } 输出：</description>
    </item>
    
    <item>
      <title>Go程序的内置函数</title>
      <link>http://wiseai.cn/post/golang/2022.07.21-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Jul 2022 22:37:24 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.21-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</guid>
      <description>6.5 内置函数 Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len()、cap() 和 append()，或必须用于系统级的操作，例如：panic()。因此，它们需要直接获得编译器的支持。
以下是一个简单的列表，我们会在后面的章节中对它们进行逐个深入的讲解。
名称 说明 close() 用于管道通信 len()、cap() len() 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap() 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 map） new()、make() new() 和 make() 均是用于分配内存：new() 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new() 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 节和第 14.2.1 节）。new() 是一个函数，不要忘记它的括号。 copy()、append() 用于复制和连接切片 panic()、recover() 两者均用于错误处理机制 print()、println() 底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包 complex()、real ()、imag() 用于创建和操作复数（详见第 4.5.2.2 节） </description>
    </item>
    
    <item>
      <title>Go程序的Defer和追踪</title>
      <link>http://wiseai.cn/post/golang/2022.07.20-defer%E5%92%8C%E8%BF%BD%E8%B8%AA/</link>
      <pubDate>Wed, 20 Jul 2022 22:35:40 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.20-defer%E5%92%8C%E8%BF%BD%E8%B8%AA/</guid>
      <description>6.4 defer 和追踪 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。
关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。
示例 6.8 defer.go：
package main import &amp;#34;fmt&amp;#34; func main() { function1() } func function1() { fmt.Printf(&amp;#34;In function1 at the top\n&amp;#34;) defer function2() fmt.Printf(&amp;#34;In function1 at the bottom!\n&amp;#34;) } func function2() { fmt.Printf(&amp;#34;Function2: Deferred until the end of the calling function!&amp;#34;) } 输出：
In Function1 at the top In Function1 at the bottom!</description>
    </item>
    
    <item>
      <title>Go程序传递变长参数</title>
      <link>http://wiseai.cn/post/golang/2022.07.19-%E4%BC%A0%E9%80%92%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 19 Jul 2022 22:34:09 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.19-%E4%BC%A0%E9%80%92%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/</guid>
      <description>6.3 传递变长参数 如果函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变参函数。
func myFunc(a, b, arg ...int) {} 这个函数接受一个类似于切片 (slice) 的参数（详见第 7 章），该参数可以通过第 5.4.4 节 中提到的 for 循环结构迭代。
示例函数和调用：
func Greeting(prefix string, who ...string) Greeting(&amp;#34;hello:&amp;#34;, &amp;#34;Joe&amp;#34;, &amp;#34;Anna&amp;#34;, &amp;#34;Eileen&amp;#34;) 在 Greeting() 函数中，变量 who 的值为 []string{&amp;quot;Joe&amp;quot;, &amp;quot;Anna&amp;quot;, &amp;quot;Eileen&amp;quot;}。
如果参数被存储在一个 slice 类型的变量 slice 中，则可以通过 slice... 的形式来传递参数，调用变参函数。
示例 6.7 varnumpar.go
package main import &amp;#34;fmt&amp;#34; func main() { x := min(1, 3, 2, 0) fmt.Printf(&amp;#34;The minimum is: %d\n&amp;#34;, x) slice := []int{7,9,3,5,1} x = min(slice.</description>
    </item>
    
    <item>
      <title>Go程序的函数参数与返回值</title>
      <link>http://wiseai.cn/post/golang/2022.07.18-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/</link>
      <pubDate>Mon, 18 Jul 2022 22:32:36 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.18-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/</guid>
      <description>6.2 函数参数与返回值 函数能够接收参数供自己使用，也可以返回零个或多个值（我们通常把返回多个值称为返回一组值）。相比与 C、C++、Java 和 C#，多值返回是 Go 的一大特性，为我们判断一个函数是否正常执行（参考 第 5.2 节）提供了方便。
我们通过 return 关键字返回一组值。事实上，任何一个有返回值（单个或多个）的函数都必须以 return 或 panic（参考 第 13 章）结尾。
在函数块里面，return 之后的语句都不会执行。如果一个函数需要返回值，那么这个函数里面的每一个代码分支 (code-path) 都要有 return 语句。
问题 6.1：下面的函数将不会被编译，为什么呢？大家可以试着纠正过来。
func (st *Stack) Pop() int { v := 0 for ix := len(st) - 1; ix &amp;gt;= 0; ix-- { if v = st[ix]; v != 0 { st[ix] = 0 return v } } } 函数定义时，它的形参一般是有名字的，不过我们也可以定义没有形参名的函数，只有相应的形参类型，就像这样：func f(int, int, float64)。
没有参数的函数通常被称为 niladic 函数 (niladic function)，就像 main.</description>
    </item>
    
    <item>
      <title>Go程序通过内存缓存来提升性能</title>
      <link>http://wiseai.cn/post/golang/2022.07.17-%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E6%9D%A5%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD/</link>
      <pubDate>Sun, 17 Jul 2022 22:29:35 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.17-%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E6%9D%A5%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD/</guid>
      <description>6.12 通过内存缓存来提升性能 当在进行大量的计算时，提升性能最直接有效的一种方式就是避免重复计算。通过在内存中缓存和重复利用相同计算的结果，称之为内存缓存。最明显的例子就是生成斐波那契数列的程序（详见第 6.6 和 6.11 节）：
要计算数列中第 n 个数字，需要先得到之前两个数的值，但很明显绝大多数情况下前两个数的值都是已经计算过的。即每个更后面的数都是基于之前计算结果的重复计算，正如示例 6.11 fibonnaci.go 所展示的那样。
而我们要做就是将第 n 个数的值存在数组中索引为 n 的位置（详见第 7 章），然后在数组中查找是否已经计算过，如果没有找到，则再进行计算。
程序 Listing 6.17 - fibonacci_memoization.go 就是依照这个原则实现的，下面是计算到第 40 位数字的性能对比：
普通写法：4.730270 秒 内存缓存：0.001000 秒 内存缓存的优势显而易见，而且您还可以将它应用到其它类型的计算中，例如使用 map（详见第 7 章）而不是数组或切片（Listing 6.21 - fibonacci_memoization.go）：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) const LIM = 41 var fibs [LIM]uint64 func main() { var result uint64 = 0 start := time.Now() for i := 0; i &amp;lt; LIM; i++ { result = fibonacci(i) fmt.</description>
    </item>
    
    <item>
      <title>Go程序计算函数执行时间</title>
      <link>http://wiseai.cn/post/golang/2022.07.16-%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 16 Jul 2022 22:27:37 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.16-%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4/</guid>
      <description>6.11 计算函数执行时间 有时候，能够知道一个计算执行消耗的时间是非常有意义的，尤其是在对比和基准测试中。最简单的一个办法就是在计算开始之前设置一个起始时间，再记录计算结束时的结束时间，最后计算它们的差值，就是这个计算所消耗的时间。想要实现这样的做法，可以使用 time 包中的 Now() 和 Sub() 函数：
start := time.Now() longCalculation() end := time.Now() delta := end.Sub(start) fmt.Printf(&amp;#34;longCalculation took this amount of time: %s\n&amp;#34;, delta) 您可以查看示例 6.20 fibonacci.go 作为实例学习。
如果您对一段代码进行了所谓的优化，请务必对它们之间的效率进行对比再做出最后的判断。在接下来的章节中，我们会学习如何进行有价值的优化操作。</description>
    </item>
    
    <item>
      <title>Go程序使用闭包调试</title>
      <link>http://wiseai.cn/post/golang/2022.07.15-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E8%B0%83%E8%AF%95/</link>
      <pubDate>Fri, 15 Jul 2022 22:25:10 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.15-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E8%B0%83%E8%AF%95/</guid>
      <description>6.10 使用闭包调试 当您在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的。您可以使用 runtime 或 log 包中的特殊函数来实现这样的功能。包 runtime 中的函数 Caller() 提供了相应的信息，因此可以在需要的时候实现一个 where() 闭包函数来打印函数执行的位置：
where := func() { _, file, line, _ := runtime.Caller(1) log.Printf(&amp;#34;%s:%d&amp;#34;, file, line) } where() // some code where() // some more code where() 您也可以设置 log 包中的 flag 参数来实现：
log.SetFlags(log.Llongfile) log.Print(&amp;#34;&amp;#34;) 或使用一个更加简短版本的 where() 函数：
var where = log.Print func func1() { where() ... some code where() ... some code where() } </description>
    </item>
    
    <item>
      <title>Go程序的函数</title>
      <link>http://wiseai.cn/post/golang/2022.07.14-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 14 Jul 2022 11:46:19 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.14-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>6.1 介绍 每一个程序都包含很多的函数：函数是基本的代码块。
Go是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。
编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务（那就是函数）来解决。而且，同一个任务（函数）可以被调用多次，有助于代码重用。
（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己 (Don&amp;rsquo;t Repeat Yourself)，意思是执行特定任务的代码只能在程序里面出现一次。）
当函数执行到代码块最后一行（} 之前）或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数；这些参数将作为返回值（参考 第 6.2 节）供调用者使用。简单的 return 语句也可以用来结束 for 死循环，或者结束一个协程 (goroutine)。
Go 里面有三种类型的函数：
普通的带有名字的函数 匿名函数或者lambda函数（参考 第 6.8 节） 方法（Methods，参考 第 10.6 节） 除了 main()、init() 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为函数签名。
作为提醒，提前介绍一个语法：
这样是不正确的 Go 代码：
func g() { } 它必须是这样的：
func g() { } 函数被调用的基本格式如下：
pack1.Function(arg1, arg2, …, argn) Function 是 pack1 包里面的一个函数，括号里的是被调用函数的实参 (argument)：这些值被传递给被调用函数的形参（parameter，参考第 6.2 节）。函数被调用的时候，这些实参将被复制（简单而言）然后传递给被调用函数。函数一般是在其他函数里面被调用的，这个其他函数被称为调用函数 (calling function)。函数能多次调用其他函数，这些被调用函数按顺序（简单而言）执行，理论上，函数调用其他函数的次数是无穷的（直到函数调用栈被耗尽）。
一个简单的函数调用其他函数的例子：
示例 6.</description>
    </item>
    
    <item>
      <title>Go程序的标签与goto</title>
      <link>http://wiseai.cn/post/golang/2022.07.13-%E6%A0%87%E7%AD%BE%E4%B8%8Egoto/</link>
      <pubDate>Wed, 13 Jul 2022 17:47:55 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.13-%E6%A0%87%E7%AD%BE%E4%B8%8Egoto/</guid>
      <description>5.6 标签与 goto for、switch 或 select 语句都可以配合标签 (label) 形式的标识符使用，即某一行第一个以冒号 (:) 结尾的单词（gofmt 会将后续代码自动移至下一行）。
示例 5.13 for6.go：
（标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母）
package main import &amp;#34;fmt&amp;#34; func main() { LABEL1: for i := 0; i &amp;lt;= 5; i++ { for j := 0; j &amp;lt;= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(&amp;#34;i is: %d, and j is: %d\n&amp;#34;, i, j) } } } 本例中，continue 语句指向 LABEL1，当执行到该语句的时候，就会跳转到 LABEL1 标签的位置。
您可以看到当 j==4 和 j==5 的时候，没有任何输出：标签的作用对象为外部循环，因此 i 会直接变成下一个循环的值，而此时 j 的值就被重设为 0，即它的初始值。如果将 continue 改为 break，则不会只退出内层循环，而是直接退出外层循环了。另外，还可以使用 goto 语句和标签配合使用来模拟循环。</description>
    </item>
    
    <item>
      <title>Go程序执行系统命令</title>
      <link>http://wiseai.cn/post/go%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 12 Jul 2022 17:56:39 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/go%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid>
      <description>直接上代码:
package main import ( &amp;#34;bytes&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os/exec&amp;#34; ) func main() { var err error var stdout, stderr string Loop: err = nil stdout, stderr = &amp;#34;&amp;#34;, &amp;#34;&amp;#34; fmt.Println(&amp;#34;1.列出当前目录中的目录和文件&amp;#34;) fmt.Println(&amp;#34;2.当前目录占用空间&amp;#34;) fmt.Println(&amp;#34;3.重启打印服务&amp;#34;) fmt.Println(&amp;#34;退出请输入9&amp;#34;) fmt.Println(&amp;#34;-----------------------------&amp;#34;) var key uint8 fmt.Scanf(&amp;#34;%d&amp;#34;, &amp;amp;key) switch key { case 1: err, stdout, stderr = shellRun(&amp;#34;ls -lh&amp;#34;) case 3: err, stdout, stderr = shellRun(&amp;#34;systemctl restart cups&amp;#34;) fmt.Println(&amp;#34;请输入密码!&amp;#34;) case 2: err, stdout, stderr = shellRun(&amp;#34;du -h&amp;#34;) fmt.Println(&amp;#34;当前目录占用空间为:&amp;#34;) case 9: fmt.</description>
    </item>
    
    <item>
      <title>Go程序的Break与continue</title>
      <link>http://wiseai.cn/post/golang/2022.07.12-break%E4%B8%8Econtinue/</link>
      <pubDate>Tue, 12 Jul 2022 17:46:18 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.12-break%E4%B8%8Econtinue/</guid>
      <description>5.5 break 与 continue 您可以使用 break 语句重写 for2.go 的代码：
示例 5.10 for3.go：
for { i = i - 1 fmt.Printf(&amp;#34;The variable i is now: %d\n&amp;#34;, i) if i &amp;lt; 0 { break } } 因此每次迭代都会对条件进行检查（i &amp;lt; 0），以此判断是否需要停止循环。如果退出条件满足，则使用 break 语句退出循环。
一个 break 的作用范围为该语句出现后的最内部的结构，它可以被用于任何形式的 for 循环（计数器、条件判断等）。但在 switch 或 select 语句中（详见第 13 章），break 语句的作用结果是跳过整个代码块，执行后续的代码。
下面的示例中包含了嵌套的循环体（for4.go），break 只会退出最内层的循环：
示例 5.11 for4.go：
package main func main() { for i:=0; i&amp;lt;3; i++ { for j:=0; j&amp;lt;10; j++ { if j&amp;gt;5 { break } print(j) } print(&amp;#34; &amp;#34;) } } 输出：</description>
    </item>
    
    <item>
      <title>Go程序的for结构</title>
      <link>http://wiseai.cn/post/golang/2022.07.11-for%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 11 Jul 2022 17:44:25 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.11-for%E7%BB%93%E6%9E%84/</guid>
      <description>5.4 for 结构 如果想要重复执行某些语句，Go 语言中您只有 for 结构可以使用。不要小看它，这个 for 结构比其它语言中的更为灵活。
注意事项 其它许多语言中也没有发现和 do-while 完全对等的 for 结构，可能是因为这种需求并不是那么强烈。
5.4.1 基于计数器的迭代 文件 for1.go 中演示了最简单的基于计数器的迭代，基本形式为：
for 初始化语句; 条件语句; 修饰语句 {} 示例 5.6 for1.go：
package main import &amp;#34;fmt&amp;#34; func main() { for i := 0; i &amp;lt; 5; i++ { fmt.Printf(&amp;#34;This is the %d iteration\n&amp;#34;, i) } } 输出：
This is the 0 iteration This is the 1 iteration This is the 2 iteration This is the 3 iteration This is the 4 iteration 由花括号括起来的代码块会被重复执行已知次数，该次数是根据计数器（此例为 i）决定的。循环开始前，会执行且仅会执行一次初始化语句 i := 0;；这比在循环之前声明更为简短。紧接着的是条件语句 i &amp;lt; 5;，在每次循环开始前都会进行判断，一旦判断结果为 false，则退出循环体。最后一部分为修饰语句 i++，一般用于增加或减少计数器。</description>
    </item>
    
    <item>
      <title>Go程序的switch结构</title>
      <link>http://wiseai.cn/post/golang/2022.07.10-switch%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 10 Jul 2022 17:42:49 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.10-switch%E7%BB%93%E6%9E%84/</guid>
      <description>5.3 switch 结构 相比较 C 和 Java 等其它语言而言，Go 语言中的 switch 结构使用上更加灵活。它接受任意形式的表达式：
switch var1 { case val1: ... case val2: ... default: ... } 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。
您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。
每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。（ Go 语言使用快速的查找算法来测试 switch 条件与 case 分支的匹配情况，直到算法匹配到某个 case 或者进入 default 条件为止。）
一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说您不需要特别使用 break 语句来表示结束。
因此，程序也不会自动地去执行下一个分支的代码。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。
因此：
switch i { case 0: // 空分支，只有当 i == 0 时才会进入分支 case 1: f() // 当 i == 0 时函数不会被调用 } 并且：</description>
    </item>
    
    <item>
      <title>Go程序的测试多返回值函数的错误</title>
      <link>http://wiseai.cn/post/golang/2022.07.09-%E6%B5%8B%E8%AF%95%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 09 Jul 2022 17:39:04 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.09-%E6%B5%8B%E8%AF%95%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF/</guid>
      <description>5.2 测试多返回值函数的错误 Go 语言的函数经常使用两个返回值来表示执行是否成功：返回某个值以及 true 表示成功；返回零值（或 nil）和 false 表示失败（第 4.4 节）。当不使用 true 或 false 的时候，也可以使用一个 error 类型的变量来代替作为第二个返回值：成功执行的话，error 的值为 nil，否则就会包含相应的错误信息（Go 语言中的错误类型为 error: var err error，我们将会在第 13 章 进行更多地讨论）。这样一来，就很明显需要用一个 if 语句来测试执行结果；由于其符号的原因，这样的形式又称之为“逗号 ok 模式”(comma, ok pattern)。
在第 4.7 节 的程序 string_conversion.go 中，函数 strconv.Atoi() 的作用是将一个字符串转换为一个整数。之前我们忽略了相关的错误检查：
anInt, _ = strconv.Atoi(origStr) 如果 origStr 不能被转换为整数，anInt 的值会变成 0 而 _ 无视了错误，程序会继续运行。
这样做是非常不好的：程序应该在最接近的位置检查所有相关的错误，至少需要暗示用户有错误发生并对函数进行返回，甚至中断程序。
我们在第二个版本中对代码进行了改进：
示例 1：
示例 5.3 string_conversion2.go
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strconv&amp;#34; ) func main() { var orig string = &amp;#34;ABC&amp;#34; // var an int var newS string // var err error fmt.</description>
    </item>
    
    <item>
      <title>Go程序的if-else结构</title>
      <link>http://wiseai.cn/post/golang/2022.07.08-if-else%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 08 Jul 2022 17:29:52 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.08-if-else%E7%BB%93%E6%9E%84/</guid>
      <description>5.1 if-else 结构 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。
if condition { // do something	} 如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行。if 和 else 后的两个代码块是相互独立的分支，只可能执行其中一个。
if condition { // do something	} else { // do something	} 如果存在第三个分支，则可以使用下面这种三个独立分支的形式：
if condition1 { // do something	} else if condition2 { // do something else	} else { // catch-all or default } else-if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else-if 结构。如果你必须使用这种形式，则把尽可能先满足的条件放在前面。
即使当代码块之间只有一条语句时，大括号也不可被省略（尽管有些人并不赞成，但这还是符合了软件工程原则的主流做法）。
关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</description>
    </item>
    
    <item>
      <title>Go程序的控制结构</title>
      <link>http://wiseai.cn/post/golang/2022.07.07-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 07 Jul 2022 17:25:40 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.07-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid>
      <description>5.0 控制结构 到目前为止，我们看到的 Go 程序都是从 main() 函数开始执行，然后按顺序执行该函数体中的代码。但我们经常会需要只有在满足一些特定情况时才执行某些代码，也就是说在代码里进行条件判断。针对这种需求，Go 提供了下面这些条件结构和分支结构：
if-else 结构 switch 结构 select 结构，用于 channel 的选择（第 14.4 节） 可以使用迭代或循环结构来重复执行一次或多次某段代码（任务）：
for (range) 结构 一些如 break 和 continue 这样的关键字可以用于中途改变循环的状态。
此外，你还可以使用 return 来结束某个函数的执行，或使用 goto 和标签来调整程序的执行位置。
Go 完全省略了 if、switch 和 for 结构中条件语句两侧的括号，相比 Java、C++ 和 C# 中减少了很多视觉混乱的因素，同时也使你的代码更加简洁。</description>
    </item>
    
    <item>
      <title>Go程序的指针</title>
      <link>http://wiseai.cn/post/golang/2022.07.06-%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 06 Jul 2022 17:19:23 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.06-%E6%8C%87%E9%92%88/</guid>
      <description>4.9 指针 不像 Java 和 .NET，Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算。通过给予程序员基本内存布局，Go 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这些对构建运行良好的系统是非常重要的：指针对于性能的影响是不言而喻的，而如果你想要做的是系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。
由于各种原因，指针对于使用面向对象编程的现代程序员来说可能显得有些陌生，不过我们将会在这一小节对此进行解释，并在未来的章节中展开深入讨论。
程序在内存中存储它的值，每个内存块（或字）有一个地址，通常用十六进制数表示，如：0x6b0820 或 0xf84001d7f0。
Go 语言的取地址符是 &amp;amp;，放到一个变量前使用就会返回相应变量的内存地址。
下面的代码片段（示例 4.9 pointer.go）可能输出 An integer: 5, its location in memory: 0x6b0820（这个值随着你每次运行程序而变化）。
var i1 = 5 fmt.Printf(&amp;#34;An integer: %d, it&amp;#39;s location in memory: %p\n&amp;#34;, i1, &amp;amp;i1) 这个地址可以存储在一个叫做指针的特殊数据类型中，在本例中这是一个指向 int 的指针，即 i1：此处使用 *int 表示。如果我们想调用指针 intP，我们可以这样声明它：
var intP *int 然后使用 intP = &amp;amp;i1 是合法的，此时 intP 指向 i1。
（指针的格式化标识符为 %p）
intP 存储了 i1 的内存地址；它指向了 i1 的位置，它引用了变量 i1。
一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。</description>
    </item>
    
    <item>
      <title>Golang生成随机字符串</title>
      <link>http://wiseai.cn/post/golang%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 06 Jul 2022 08:54:04 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>假如我们要生成一个固定长度的随机字符串，包含大小写字母，没有数字，没有特殊字符串，那么我们怎么做呢？需要怎样优化，才会更简单，更高效？在最终的方案之前，我们看看最常见的写法是怎样的，然后是如何一步步演进到最终的高效率方案的。好吧，先看下最原始的方案。
常见做法(Runes) func init() { rand.Seed(time.Now().UnixNano()) } var letterRunes = []rune(&amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;) func RandStringRunes(n int) string { b := make([]rune, n) for i := range b { b[i] = letterRunes[rand.Intn(len(letterRunes))] } return string(b) } 这个实现比较简单，二十六字母（大小写），然后随机取数，获得随机字符串。
Bytes改进 我们在最开始的时候进行了假设，我们的随机字符串只包含大小写字母，这样的话，我们发现没有必要使用rune类型存储，因为在Golang（Go语言）UTF-8编码下，英文字母和byte字节是一对一的。byte的本质是uint8类型，而rune本质是int32类型。我们改进后的代码如下：
const letterBytes = &amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34; func RandStringBytes(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } 仔细看上面的代码，我们不光对rune类型进行了改进，还把原来的letter变量变成了常量，这样len(letterBytes)也是一个常量，代码的效率将大大提升。
余数改进 我们前面的方案都是通过调用rand.Intn()生成的随机字符，这个rand.Intn()其实是委托调用的Rand.Intn(),而Rand.Intn()最终又是调用的Rand.Int31n()实现。相比我们直接调用rand.Int63()来说，rand.Intn()要慢很多。
所以我们可以把rand.Intn()换成rand.Int63()来提高效率，为了不超过letterBytes的索引范围，我们使用余数来保证。
func RandStringBytesRmndr(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.</description>
    </item>
    
    <item>
      <title>Go程序的时间和日期</title>
      <link>http://wiseai.cn/post/golang/2022.07.05-%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F/</link>
      <pubDate>Tue, 05 Jul 2022 11:18:29 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.05-%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F/</guid>
      <description>4.8 时间和日期 time 包为我们提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数。
当前时间可以使用 time.Now() 获取，或者使用 t.Day()、t.Minute() 等等来获取时间的一部分；你甚至可以自定义时间格式化字符串，例如： fmt.Printf(&amp;quot;%02d.%02d.%4d\n&amp;quot;, t.Day(), t.Month(), t.Year()) 将会输出 21.07.2011。
Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。
包中的一个预定义函数 func (t Time) Format(layout string) string 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，你可以使用一些预定义的格式，如：time.ANSIC 或 time.RFC822。
一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，这听起来很奇怪（02 Jan 2006 15:04 是 Go 语言的诞生时间且自定义格式化时必须以此时间为基准），但看下面这个例子你就会一目了然：
fmt.Println(t.Format(&amp;#34;02 Jan 2006 15:04&amp;#34;)) 输出：
21 Jul 2011 10:31 其它有关时间操作的文档请参阅 官方文档（ 译者注：国内用户可访问 该页面 ）。
示例 4.20 time.go
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) var week time.Duration func main() { t := time.</description>
    </item>
    
    <item>
      <title>Go程序的 Strings 和 strconv 包</title>
      <link>http://wiseai.cn/post/golang/2022.07.01-strings%E5%92%8Cstrconv%E5%8C%85/</link>
      <pubDate>Fri, 01 Jul 2022 10:14:36 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.01-strings%E5%92%8Cstrconv%E5%8C%85/</guid>
      <description>4.7 strings 和 strconv 包 作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 strings 包来完成对字符串的主要操作。
4.7.1 前缀和后缀 HasPrefix() 判断字符串 s 是否以 prefix 开头：
strings.HasPrefix(s, prefix string) bool HasSuffix() 判断字符串 s 是否以 suffix 结尾：
strings.HasSuffix(s, suffix string) bool package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { var str string = &amp;#34;This is an example of a string&amp;#34; fmt.Printf(&amp;#34;T/F? Does the string \&amp;#34;%s\&amp;#34; have prefix %s? &amp;#34;, str, &amp;#34;Th&amp;#34;) fmt.Printf(&amp;#34;%t\n&amp;#34;, strings.HasPrefix(str, &amp;#34;Th&amp;#34;)) } 输出：
T/F? Does the string &amp;quot;This is an example of a string&amp;quot; have prefix Th?</description>
    </item>
    
    <item>
      <title>Go程序的字符串</title>
      <link>http://wiseai.cn/post/golang/2022.06.30-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 30 Jun 2022 09:37:08 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.30-%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>4.6 字符串 字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串里面的字符也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。
字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。
Go 支持以下 2 种形式的字面值：
解释字符串：
该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：
\n：换行符 \r：回车符 \t：tab 键 \u 或 \U：Unicode 字符 \\：反斜杠自身 非解释字符串：
该类字符串使用反引号括起来，支持换行，例如：
`This is a raw string \n` 中的 `\n\` 会被原样输出。 和 C/C++不一样，Go 中的字符串是根据长度限定，而非特殊字符 \0。
string 类型的零值为长度为零的字符串，即空字符串 &amp;quot;&amp;quot;。
一般的比较运算符（==、!=、&amp;lt;、&amp;lt;=、&amp;gt;=、&amp;gt;）通过在内存中按字节比较来实现字符串的对比。你可以通过函数 len() 来获取字符串所占的字节长度，例如：len(str)。
字符串的内容（纯字节）可以通过标准索引法来获取，在中括号 [] 内写入索引，索引从 0 开始计数：</description>
    </item>
    
    <item>
      <title>Go程序的基本类型和运算符</title>
      <link>http://wiseai.cn/post/golang/2022.06.29-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 29 Jun 2022 11:33:14 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.29-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>4.5 基本类型和运算符 我们将在这个部分讲解有关布尔型、数字型和字符型的相关知识。
表达式是一种特定的类型的值，它可以由其它的值以及运算符组合而成。每个类型都定义了可以和自己结合的运算符集合，如果你使用了不在这个集合中的运算符，则会在编译时获得编译错误。
一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）。
只有两个类型相同的值才可以和二元运算符结合，另外要注意的是，Go 是强类型语言，因此不会进行隐式转换，任何不同类型之间的转换都必须显式说明（第 4.2 节）。Go 不存在像 C 那样的运算符重载，表达式的解析顺序是从左至右。
你可以在第 4.5.3 节找到有关运算符优先级的相关信息，优先级越高的运算符在条件相同的情况下将被优先执行。但是你可以通过使用括号将其中的表达式括起来，以人为地提升某个表达式的运算优先级。
4.5.1 布尔类型 bool 一个简单的例子：var b bool = true。
布尔型的值只可以是常量 true 或者 false。
两个类型相同的值可以使用相等 == 或者不等 != 运算符来进行比较并获得一个布尔型的值。
当相等运算符两边的值是完全相同的值的时候会返回 true，否则返回 false，并且只有在两个的值的类型相同的情况下才可以使用。
示例：
var aVar = 10 aVar == 5 -&amp;gt; false aVar == 10 -&amp;gt; true 当不等运算符两边的值是不同的时候会返回 true，否则返回 false。
示例：
var aVar = 10 aVar != 5 -&amp;gt; true aVar != 10 -&amp;gt; false Go 对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface，第 11 章），它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。</description>
    </item>
    
    <item>
      <title>Go程序的变量</title>
      <link>http://wiseai.cn/post/golang/2022.06.27-%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 27 Jun 2022 11:46:14 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.27-%E5%8F%98%E9%87%8F/</guid>
      <description>4.4 变量 4.4.1 简介 声明变量的一般形式是使用 var 关键字：var identifier type。
需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？
首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b;。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写（你可以在 Go 语言的声明语法 页面找到有关于这个话题的更多讨论）。
而在 Go 中，则可以很轻松地将它们都声明为指针类型：
var a, b *int 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。
示例：
var a int var b bool var str string 你也可以改写成这种形式：
var ( a int b bool str string ) 这种因式分解关键字的写法一般用于声明全局变量。
当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float32(64) 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。
变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate。
但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（第 4.2 节：可见性规则）。</description>
    </item>
    
    <item>
      <title>Go程序的常量</title>
      <link>http://wiseai.cn/post/golang/2022.06.27-%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 27 Jun 2022 11:36:06 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.27-%E5%B8%B8%E9%87%8F/</guid>
      <description>4.3 常量 常量使用关键字 const 定义，用于存储不会改变的数据。
存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
常量的定义格式：const identifier [type] = value，例如：
const Pi = 3.14159 在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。
显式类型定义： const b string = &amp;quot;abc&amp;quot; 隐式类型定义： const b = &amp;quot;abc&amp;quot; 一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。
var n int f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。
正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。
数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：
const Ln2 = 0.693147180559945309417232121458\ 176568075500134360255254120680009 const Log2E = 1/Ln2 // this is a precise reciprocal const Billion = 1e9 // float constant const hardEight = (1 &amp;lt;&amp;lt; 100) &amp;gt;&amp;gt; 97 根据上面的例子我们可以看到，反斜杠 \ 可以在常量表达式中作为多行的连接符使用。</description>
    </item>
    
    <item>
      <title>大数的阶乘</title>
      <link>http://wiseai.cn/post/%E5%A4%A7%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98/</link>
      <pubDate>Mon, 27 Jun 2022 10:38:51 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/%E5%A4%A7%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98/</guid>
      <description>直接上代码:
C语言: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;time.h&amp;gt; //给计算结果一个数组，并指定大小为4096 //第一次写程序使用的字符串保存大数，但是有个问题，需要char到int来回转换，影响计算性能。 //所以使用数组来保存数据，方便计算 int jieguo[40960] = {0}; //数组长度 int len = 0; //fac为计算阶乘的函数，计算结果存储在jieguo[4096]数组中 int fac(int n) { int v = 0; int f = 0; //初始化jieguo数组和数组长度 jieguo[0] = 1; len = 1; for(int i = 1; i &amp;lt;= n; i++) { for(int j = len - 1; j &amp;gt;= 0; j--) { v = i * jieguo[j]; jieguo[j] = v % 10; v = v / 10; f = j + 1; //如果v大于0，说明还要进位，所以将进位的数加上原来的数，判断进位后存储。 //为了提高效率，使用for进行循环 for(; v &amp;gt; 0 &amp;amp;&amp;amp; f &amp;lt; len; f++) { v = v + jieguo[f]; jieguo[f] = v % 10; v = v / 10; } //如果这时f等于数组的长度len并且v还大于0，说明需要增加jieguo数组的长度 //为了提高效率，仍然使用for进行循环 for(; v &amp;gt; 0;) { jieguo[len] = v % 10; v = v / 10; len++; if(len &amp;gt; 40960 - 2) { //这个时候说明数组长度不够，需要增加jieguo后面的数值 //计算100的阶乘的数组长度为158，计算1000的阶乘的数组长度为2568。 //可以根据实际需要进行设置。 return 1; } } }	} return 0; } //下面写主函数 int main(void) { int num; printf(&amp;#34;请输入需要计算阶乘的数字:&amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;num); //计算阶乘结果 int r = fac(num); //如果返回1,则说明数组长度不够，需要增加长度 if(r == 1) { printf(&amp;#34;计算结果太大，请增加数组长度！\n&amp;#34;); return 0; } printf(&amp;#34;%d的阶乘为：&amp;#34;, num); for(int i = len - 1; i &amp;gt;= 0; i--) { printf(&amp;#34;%d&amp;#34;, jieguo[i]); } printf(&amp;#34;\n&amp;#34;); printf(&amp;#34;%d\n&amp;#34;, len); printf(&amp;#34;运行时间:%.</description>
    </item>
    
    <item>
      <title>Go程序的基本结构和要素</title>
      <link>http://wiseai.cn/post/golang/2022.06.22-go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/</link>
      <pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.22-go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/</guid>
      <description>4.2 Go 程序的基本结构和要素 示例 hello_world.go
package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;hello, world&amp;#34;) } 4.2.1 包的概念、导入与可见性 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。
如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。
你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。
标准库
在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。
Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包（第 9 章）。</description>
    </item>
    
  </channel>
</rss>
