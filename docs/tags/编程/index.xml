<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on WiseAI的博客</title>
    <link>http://wiseai.cn/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on WiseAI的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>陇ICP备15000157号</copyright>
    <lastBuildDate>Wed, 06 Jul 2022 08:54:04 +0800</lastBuildDate><atom:link href="http://wiseai.cn/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang生成随机字符串</title>
      <link>http://wiseai.cn/post/golang%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 06 Jul 2022 08:54:04 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>假如我们要生成一个固定长度的随机字符串，包含大小写字母，没有数字，没有特殊字符串，那么我们怎么做呢？需要怎样优化，才会更简单，更高效？在最终的方案之前，我们看看最常见的写法是怎样的，然后是如何一步步演进到最终的高效率方案的。好吧，先看下最原始的方案。
常见做法(Runes) func init() { rand.Seed(time.Now().UnixNano()) } var letterRunes = []rune(&amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;) func RandStringRunes(n int) string { b := make([]rune, n) for i := range b { b[i] = letterRunes[rand.Intn(len(letterRunes))] } return string(b) } 这个实现比较简单，二十六字母（大小写），然后随机取数，获得随机字符串。
Bytes改进 我们在最开始的时候进行了假设，我们的随机字符串只包含大小写字母，这样的话，我们发现没有必要使用rune类型存储，因为在Golang（Go语言）UTF-8编码下，英文字母和byte字节是一对一的。byte的本质是uint8类型，而rune本质是int32类型。我们改进后的代码如下：
const letterBytes = &amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34; func RandStringBytes(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } 仔细看上面的代码，我们不光对rune类型进行了改进，还把原来的letter变量变成了常量，这样len(letterBytes)也是一个常量，代码的效率将大大提升。
余数改进 我们前面的方案都是通过调用rand.Intn()生成的随机字符，这个rand.Intn()其实是委托调用的Rand.Intn(),而Rand.Intn()最终又是调用的Rand.Int31n()实现。相比我们直接调用rand.Int63()来说，rand.Intn()要慢很多。
所以我们可以把rand.Intn()换成rand.Int63()来提高效率，为了不超过letterBytes的索引范围，我们使用余数来保证。
func RandStringBytesRmndr(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.</description>
    </item>
    
    <item>
      <title>Go程序的 Strings 和 strconv 包</title>
      <link>http://wiseai.cn/post/golang/2022.07.01-strings%E5%92%8Cstrconv%E5%8C%85/</link>
      <pubDate>Fri, 01 Jul 2022 10:14:36 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.07.01-strings%E5%92%8Cstrconv%E5%8C%85/</guid>
      <description>4.7 strings 和 strconv 包 作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 strings 包来完成对字符串的主要操作。
4.7.1 前缀和后缀 HasPrefix() 判断字符串 s 是否以 prefix 开头：
strings.HasPrefix(s, prefix string) bool HasSuffix() 判断字符串 s 是否以 suffix 结尾：
strings.HasSuffix(s, suffix string) bool package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { var str string = &amp;#34;This is an example of a string&amp;#34; fmt.Printf(&amp;#34;T/F? Does the string \&amp;#34;%s\&amp;#34; have prefix %s? &amp;#34;, str, &amp;#34;Th&amp;#34;) fmt.Printf(&amp;#34;%t\n&amp;#34;, strings.HasPrefix(str, &amp;#34;Th&amp;#34;)) } 输出：
T/F? Does the string &amp;quot;This is an example of a string&amp;quot; have prefix Th?</description>
    </item>
    
    <item>
      <title>Go程序的字符串</title>
      <link>http://wiseai.cn/post/golang/2022.06.30-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 30 Jun 2022 09:37:08 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.30-%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>4.6 字符串 字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串里面的字符也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。
字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。
Go 支持以下 2 种形式的字面值：
解释字符串：
该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：
\n：换行符 \r：回车符 \t：tab 键 \u 或 \U：Unicode 字符 \\：反斜杠自身 非解释字符串：
该类字符串使用反引号括起来，支持换行，例如：
`This is a raw string \n` 中的 `\n\` 会被原样输出。 和 C/C++不一样，Go 中的字符串是根据长度限定，而非特殊字符 \0。
string 类型的零值为长度为零的字符串，即空字符串 &amp;quot;&amp;quot;。
一般的比较运算符（==、!=、&amp;lt;、&amp;lt;=、&amp;gt;=、&amp;gt;）通过在内存中按字节比较来实现字符串的对比。你可以通过函数 len() 来获取字符串所占的字节长度，例如：len(str)。
字符串的内容（纯字节）可以通过标准索引法来获取，在中括号 [] 内写入索引，索引从 0 开始计数：</description>
    </item>
    
    <item>
      <title>Go程序的基本类型和运算符</title>
      <link>http://wiseai.cn/post/golang/2022.06.29-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 29 Jun 2022 11:33:14 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.29-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>4.5 基本类型和运算符 我们将在这个部分讲解有关布尔型、数字型和字符型的相关知识。
表达式是一种特定的类型的值，它可以由其它的值以及运算符组合而成。每个类型都定义了可以和自己结合的运算符集合，如果你使用了不在这个集合中的运算符，则会在编译时获得编译错误。
一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）。
只有两个类型相同的值才可以和二元运算符结合，另外要注意的是，Go 是强类型语言，因此不会进行隐式转换，任何不同类型之间的转换都必须显式说明（第 4.2 节）。Go 不存在像 C 那样的运算符重载，表达式的解析顺序是从左至右。
你可以在第 4.5.3 节找到有关运算符优先级的相关信息，优先级越高的运算符在条件相同的情况下将被优先执行。但是你可以通过使用括号将其中的表达式括起来，以人为地提升某个表达式的运算优先级。
4.5.1 布尔类型 bool 一个简单的例子：var b bool = true。
布尔型的值只可以是常量 true 或者 false。
两个类型相同的值可以使用相等 == 或者不等 != 运算符来进行比较并获得一个布尔型的值。
当相等运算符两边的值是完全相同的值的时候会返回 true，否则返回 false，并且只有在两个的值的类型相同的情况下才可以使用。
示例：
var aVar = 10 aVar == 5 -&amp;gt; false aVar == 10 -&amp;gt; true 当不等运算符两边的值是不同的时候会返回 true，否则返回 false。
示例：
var aVar = 10 aVar != 5 -&amp;gt; true aVar != 10 -&amp;gt; false Go 对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface，第 11 章），它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。</description>
    </item>
    
    <item>
      <title>Go程序的变量</title>
      <link>http://wiseai.cn/post/golang/2022.06.27-%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 27 Jun 2022 11:46:14 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.27-%E5%8F%98%E9%87%8F/</guid>
      <description>4.4 变量 4.4.1 简介 声明变量的一般形式是使用 var 关键字：var identifier type。
需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？
首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b;。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写（你可以在 Go 语言的声明语法 页面找到有关于这个话题的更多讨论）。
而在 Go 中，则可以很轻松地将它们都声明为指针类型：
var a, b *int 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。
示例：
var a int var b bool var str string 你也可以改写成这种形式：
var ( a int b bool str string ) 这种因式分解关键字的写法一般用于声明全局变量。
当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float32(64) 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。
变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate。
但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（第 4.2 节：可见性规则）。</description>
    </item>
    
    <item>
      <title>Go程序的常量</title>
      <link>http://wiseai.cn/post/golang/2022.06.27-%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 27 Jun 2022 11:36:06 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.27-%E5%B8%B8%E9%87%8F/</guid>
      <description>4.3 常量 常量使用关键字 const 定义，用于存储不会改变的数据。
存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
常量的定义格式：const identifier [type] = value，例如：
const Pi = 3.14159 在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。
显式类型定义： const b string = &amp;quot;abc&amp;quot; 隐式类型定义： const b = &amp;quot;abc&amp;quot; 一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。
var n int f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。
正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。
数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：
const Ln2 = 0.693147180559945309417232121458\ 176568075500134360255254120680009 const Log2E = 1/Ln2 // this is a precise reciprocal const Billion = 1e9 // float constant const hardEight = (1 &amp;lt;&amp;lt; 100) &amp;gt;&amp;gt; 97 根据上面的例子我们可以看到，反斜杠 \ 可以在常量表达式中作为多行的连接符使用。</description>
    </item>
    
    <item>
      <title>大数的阶乘</title>
      <link>http://wiseai.cn/post/%E5%A4%A7%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98/</link>
      <pubDate>Mon, 27 Jun 2022 10:38:51 +0800</pubDate>
      
      <guid>http://wiseai.cn/post/%E5%A4%A7%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98/</guid>
      <description>直接上代码:
C语言: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;time.h&amp;gt; //给计算结果一个数组，并指定大小为4096 //第一次写程序使用的字符串保存大数，但是有个问题，需要char到int来回转换，影响计算性能。 //所以使用数组来保存数据，方便计算 int jieguo[40960] = {0}; //数组长度 int len = 0; //fac为计算阶乘的函数，计算结果存储在jieguo[4096]数组中 int fac(int n) { int v = 0; int f = 0; //初始化jieguo数组和数组长度 jieguo[0] = 1; len = 1; for(int i = 1; i &amp;lt;= n; i++) { for(int j = len - 1; j &amp;gt;= 0; j--) { v = i * jieguo[j]; jieguo[j] = v % 10; v = v / 10; f = j + 1; //如果v大于0，说明还要进位，所以将进位的数加上原来的数，判断进位后存储。 //为了提高效率，使用for进行循环 for(; v &amp;gt; 0 &amp;amp;&amp;amp; f &amp;lt; len; f++) { v = v + jieguo[f]; jieguo[f] = v % 10; v = v / 10; } //如果这时f等于数组的长度len并且v还大于0，说明需要增加jieguo数组的长度 //为了提高效率，仍然使用for进行循环 for(; v &amp;gt; 0;) { jieguo[len] = v % 10; v = v / 10; len++; if(len &amp;gt; 40960 - 2) { //这个时候说明数组长度不够，需要增加jieguo后面的数值 //计算100的阶乘的数组长度为158，计算1000的阶乘的数组长度为2568。 //可以根据实际需要进行设置。 return 1; } } }	} return 0; } //下面写主函数 int main(void) { int num; printf(&amp;#34;请输入需要计算阶乘的数字:&amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;num); //计算阶乘结果 int r = fac(num); //如果返回1,则说明数组长度不够，需要增加长度 if(r == 1) { printf(&amp;#34;计算结果太大，请增加数组长度！\n&amp;#34;); return 0; } printf(&amp;#34;%d的阶乘为：&amp;#34;, num); for(int i = len - 1; i &amp;gt;= 0; i--) { printf(&amp;#34;%d&amp;#34;, jieguo[i]); } printf(&amp;#34;\n&amp;#34;); printf(&amp;#34;%d\n&amp;#34;, len); printf(&amp;#34;运行时间:%.</description>
    </item>
    
    <item>
      <title>Go程序的基本结构和要素</title>
      <link>http://wiseai.cn/post/golang/2022.06.22-go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/</link>
      <pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>http://wiseai.cn/post/golang/2022.06.22-go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/</guid>
      <description>4.2 Go 程序的基本结构和要素 示例 hello_world.go
package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;hello, world&amp;#34;) } 4.2.1 包的概念、导入与可见性 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。
如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。
你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。
标准库
在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。
Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包（第 9 章）。</description>
    </item>
    
  </channel>
</rss>
