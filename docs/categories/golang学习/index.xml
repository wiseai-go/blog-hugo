<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang学习 on WiseAI的博客</title>
    <link>https://blog.wiseai.cn/categories/golang%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in golang学习 on WiseAI的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>陇ICP备15000157号</copyright>
    <lastBuildDate>Mon, 27 Jun 2022 11:46:14 +0800</lastBuildDate><atom:link href="https://blog.wiseai.cn/categories/golang%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go程序的变量</title>
      <link>https://blog.wiseai.cn/post/golang/%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 27 Jun 2022 11:46:14 +0800</pubDate>
      
      <guid>https://blog.wiseai.cn/post/golang/%E5%8F%98%E9%87%8F/</guid>
      <description>4.4 变量 4.4.1 简介 声明变量的一般形式是使用 var 关键字：var identifier type。
需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？
首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b;。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写（你可以在 Go 语言的声明语法 页面找到有关于这个话题的更多讨论）。
而在 Go 中，则可以很轻松地将它们都声明为指针类型：
1  var a, b *int   其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。
示例：
1 2 3  var a int var b bool var str string   你也可以改写成这种形式：
1 2 3 4 5  var ( a int b bool str string )   这种因式分解关键字的写法一般用于声明全局变量。</description>
    </item>
    
    <item>
      <title>Go程序的常量</title>
      <link>https://blog.wiseai.cn/post/golang/%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 27 Jun 2022 11:36:06 +0800</pubDate>
      
      <guid>https://blog.wiseai.cn/post/golang/%E5%B8%B8%E9%87%8F/</guid>
      <description>4.3 常量 常量使用关键字 const 定义，用于存储不会改变的数据。
存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
常量的定义格式：const identifier [type] = value，例如：
1  const Pi = 3.14159   在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。
 显式类型定义： const b string = &amp;quot;abc&amp;quot; 隐式类型定义： const b = &amp;quot;abc&amp;quot;  一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。
1 2  var n int f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int   常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。
 正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value  因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。</description>
    </item>
    
    <item>
      <title>大数的阶乘</title>
      <link>https://blog.wiseai.cn/post/%E5%A4%A7%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98/</link>
      <pubDate>Mon, 27 Jun 2022 10:38:51 +0800</pubDate>
      
      <guid>https://blog.wiseai.cn/post/%E5%A4%A7%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98/</guid>
      <description>直接上代码:
C语言: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;time.h&amp;gt; //给计算结果一个数组，并指定大小为4096 //第一次写程序使用的字符串保存大数，但是有个问题，需要char到int来回转换，影响计算性能。 //所以使用数组来保存数据，方便计算 int jieguo[40960] = {0}; //数组长度 int len = 0; //fac为计算阶乘的函数，计算结果存储在jieguo[4096]数组中 int fac(int n) { int v = 0; int f = 0; //初始化jieguo数组和数组长度 jieguo[0] = 1; len = 1; for(int i = 1; i &amp;lt;= n; i++) { for(int j = len - 1; j &amp;gt;= 0; j--) { v = i * jieguo[j]; jieguo[j] = v % 10; v = v / 10; f = j + 1; //如果v大于0，说明还要进位，所以将进位的数加上原来的数，判断进位后存储。 //为了提高效率，使用for进行循环 for(; v &amp;gt; 0 &amp;amp;&amp;amp; f &amp;lt; len; f++) { v = v + jieguo[f]; jieguo[f] = v % 10; v = v / 10; } //如果这时f等于数组的长度len并且v还大于0，说明需要增加jieguo数组的长度 //为了提高效率，仍然使用for进行循环 for(; v &amp;gt; 0;) { jieguo[len] = v % 10; v = v / 10; len++; if(len &amp;gt; 40960 - 2) { //这个时候说明数组长度不够，需要增加jieguo后面的数值 //计算100的阶乘的数组长度为158，计算1000的阶乘的数组长度为2568。 //可以根据实际需要进行设置。 return 1; } } }	} return 0; } //下面写主函数 int main(void) { int num; printf(&amp;#34;请输入需要计算阶乘的数字:&amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;num); //计算阶乘结果 int r = fac(num); //如果返回1,则说明数组长度不够，需要增加长度 if(r == 1) { printf(&amp;#34;计算结果太大，请增加数组长度！\n&amp;#34;); return 0; } printf(&amp;#34;%d的阶乘为：&amp;#34;, num); for(int i = len - 1; i &amp;gt;= 0; i--) { printf(&amp;#34;%d&amp;#34;, jieguo[i]); } printf(&amp;#34;\n&amp;#34;); printf(&amp;#34;%d\n&amp;#34;, len); printf(&amp;#34;运行时间:%.</description>
    </item>
    
    <item>
      <title>Go程序的基本结构和要素</title>
      <link>https://blog.wiseai.cn/post/golang/go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/</link>
      <pubDate>Wed, 22 Jun 2022 14:23:01 +0800</pubDate>
      
      <guid>https://blog.wiseai.cn/post/golang/go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/</guid>
      <description>4.2 Go 程序的基本结构和要素 示例 hello_world.go
1 2 3 4 5  package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;hello, world&amp;#34;) }   4.2.1 包的概念、导入与可见性 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。
如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。
你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。
标准库
在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。</description>
    </item>
    
    <item>
      <title>golang和nodejs环境配置</title>
      <link>https://blog.wiseai.cn/post/golang%E5%92%8Cnodejs%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.wiseai.cn/post/golang%E5%92%8Cnodejs%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>配置golang   下载文件：golang官网下载 解压文件至/usr/local/目录下：  # rm -rf /usr/local/go &amp;amp;&amp;amp; tar -C /usr/local -xzf go1.17.6.linux-amd64.tar.gz
（第一个命令是删除golang的残余文件）
 建立软链接至/usr/bin/目录下：  # ln -s /usr/local/go/bin/go /usr/bin/
# ln -s /usr/local/go/bin/gofmt /usr/bin/
 修改为国内源  # go env -w GO111MODULE=auto 
# go env -w GOPROXY=https://goproxy.cn,direct
 查看配置  # go env
配置nodejs   下载文件：nodejs官网 解压文件至/usr/local/目录下：  # rm -rf /usr/local/go &amp;amp;&amp;amp; tar -C /usr/local -xzf go1.17.6.linux-amd64.tar.gz
（第一个命令是删除nodejs的残余文件） # npm install yarn</description>
    </item>
    
    <item>
      <title>golang的build命令</title>
      <link>https://blog.wiseai.cn/post/golang%E7%9A%84build%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.wiseai.cn/post/golang%E7%9A%84build%E5%91%BD%E4%BB%A4/</guid>
      <description>go build，是我们非常常用的命令，它可以启动编译，把我们的包和相关的依赖编译成一个可执行的文件。
usage: go build [-o output] [-i] [build flags] [packages]
go build的使用比较简洁，所有的参数都可以忽略，直到只有go build，这个时候意味着使用当前目录进行编译，下面的几条命令是等价的：
go build go build . go build hello.go 以上这三种写法，都是使用当前目录编译的意思。因为我们忽略了packages,所以自然就使用当前目录进行编译了。从这里我们也可以推测出，go build本质上需要的是一个路径，让编译器可以找到哪些需要编译的go文件。packages其实是一个相对路径，是相对于我们定义的GOROOT和GOPATH这两个环境变量的，所以有了packages这个参数后，go build就可以知道哪些需要编译的go文件了。
go build flysnow.org/tools
这种方式是指定包的方式，这样会明确地编译我们这个包。当然我们也可以使用通配符
go build flysnow.org/tools/...
** 3个点表示匹配所有字符串，这样go build就会编译tools目录下的所有包。**
讲到go build编译，不能不提跨平台编译，Go提供了编译链工具，可以让我们在任何一个开发平台上，编译出其他平台的可执行文件。
默认情况下，都是根据我们当前的机器生成的可执行文件，比如你的是Linux 64位，就会生成Linux 64位下的可执行文件，比如我的Mac；可以使用go env查看编译环境,以下截取重要的部分。
go env GOARCH=&amp;#34;amd64&amp;#34; GOEXE=&amp;#34;&amp;#34; GOHOSTARCH=&amp;#34;amd64&amp;#34; GOHOSTOS=&amp;#34;darwin&amp;#34; GOOS=&amp;#34;darwin&amp;#34; GOROOT=&amp;#34;/usr/local/go&amp;#34; GOTOOLDIR=&amp;#34;/usr/local/go/pkg/tool/darwin_amd64&amp;#34; ** 注意里面两个重要的环境变量GOOS和GOARCH,其中GOOS指的是目标操作系统，它的可用值为：**
 darwin freebsd linux windows android dragonfly netbsd openbsd plan9 solaris  ** 一共支持10种操作系统。GOARCH指的是目标处理器的架构，目前支持的有：**
 arm arm64 386 amd64 ppc64 ppc64le mips64 mips64le s390x  一共支持9种处理器的架构</description>
    </item>
    
  </channel>
</rss>
